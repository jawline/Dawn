#include <settings/settingsmanager.h>
#include <stdlib.h>
#include <debug/debug.h>
#include <types/size_t.h>
#include <fs/vfs.h>

///TODO: Rewrite the line evaluator so its more robust

/*
	GLOBAL VARIABLES
*/

settingsEntry* settingsListStart = 0;

/*
	FUNCTION DEFINITIONS
*/

settingsEntry* settingsGetEntry(const char* Name);
void settingsCreateEntry(const char* Name, const char* Data);
void parseConfigFile(const char* Filename);
void settingsModifyEntry(settingsEntry* Entry, const char* newData);

/*
	PUBLIC FUNCTIONS
 */

/**
 * Initializes the settings manager
 * Loads base settings from /system/root/kernel.config
 **/
void initializeSettingsManager()
{
	DEBUG_PRINT("Initialized settings manager\n");

	settingsListStart = 0;

	parseConfigFile("/system/system.config");
	parseConfigFile("/system/kconf.config");
}

/**
 * Executes a line, like a query and returns any results there may be
 */

const char* settingsExecuteLine(const char* line)
{

	size_t length = strlen(line);

	const char* FirstSpace = strchr(line, ' ');

	if (FirstSpace == 0)
	{
		DEBUG_PRINT("SETTINGS: ERROR INVALID COMMAND\n");
		return "FAIL";
	}

	const char* SecondSpace = strchr(FirstSpace + 1, ' ');

	if (SecondSpace == 0)
	{
		DEBUG_PRINT("SETTINGS: ERROR INVALID COMMAND\n");
		return "FAIL";
	}

	const char* End = line + length;


	if (*(FirstSpace + 1) != '=')
	{
		DEBUG_PRINT("SETTINGS: ERROR INVALID COMMAND\n");
		return "FAIL";
	}

	if (FirstSpace - line == 0)
	{
		DEBUG_PRINT("SETTINGS: ERROR INVALID COMMAND\n");
		return "FAIL";
	}

	if (End - SecondSpace == 0)
	{
		DEBUG_PRINT("SETTINGS: ERROR INVALID COMMAND\n");
		return "FAIL";
	}

	char* Name = malloc(length + 2);
	memcpy(Name, line, FirstSpace - line);
	Name[FirstSpace - line] = '\0';

	char* Data = malloc(length + 2);
	memcpy(Data, SecondSpace + 1, End - SecondSpace - 1);
	Data[End - SecondSpace - 1] = '\0';

	settingsEntry* oldEntry = settingsGetEntry(Name);

	if (oldEntry == 0)
	{
		//Create a new entry
		settingsCreateEntry(Name, Data);
	}
	else
	{
		//Reuse a old entry
		settingsModifyEntry(oldEntry, Data);
	}

	free(Name);
	free(Data);

	return "FINE";
}

/**
 * Reads the value of the specified settings entry
 **/

const char* settingsReadValue(char const* name, char const* default)
{
	settingsEntry* entry = settingsGetEntry(name);

	if (entry == 0)
	{
		return "";
	}
	else
	{
		return entry->Data;
	}
}

/*
	PRIVATE FUNCTIONS
 */

void parseConfigFile(const char* Filename)
{
    DEBUG_PRINT("Parsing configuration file %s\n", Filename);

	fs_node_t* cfgNode = evaluatePath(Filename, init_vfs());

	if (cfgNode == 0) return;

	char cfgBuffer[1024];
	memset(cfgBuffer, 0, 1024);

	size_t length = cfgNode->length;
	size_t current = 0;
	size_t iter = 0;


	open_fs(cfgNode);


	while (1)
	{
		if (current >= cfgNode->length)
			break;

		read_fs(cfgNode, current, 1, (uint8_t*) cfgBuffer + iter);

		if (*(cfgBuffer + iter) == '\n')
		{
			*(cfgBuffer + iter) = '\0';
			iter = 0;

			settingsExecuteLine(cfgBuffer);

			memset(cfgBuffer, 0, 1024);
		}
		else
		{
			iter++;
		}

		current++;
	}

	close_fs(cfgNode);
}

settingsEntry* settingsGetEntry(const char* Name)
{
	if (settingsListStart != 0)
	{
		settingsEntry* iter = settingsListStart;

		while (iter->next != 0)
		{

			if (strcmp(Name, iter->Name) == 0)
			{
				break;
			}

			iter = iter->next;
		}

		//Double check
		if (strcmp(Name, iter->Name) != 0)
		{
			return 0;
		}

		return iter;

	}

	return 0;
}

settingsEntry* settingsGetLastEntry()
{
	if (settingsListStart != 0)
	{
		settingsEntry* iter = settingsListStart;

		while (iter->next != 0)
		{
			iter = iter->next;
		}

		return iter;

	}

	return 0;
}

void settingsModifyEntry(settingsEntry* Entry, const char* newData)
{
	if (Entry->Data != 0)
	{
		free(Entry->Data);
	}

	Entry->Data = malloc(strlen(newData) + 1);
	strcpy(Entry->Data, newData);

	return;
}

void settingsCreateEntry(const char* Name, const char* Data)
{
	settingsEntry* entryCheck = settingsGetEntry(Name);

	if (entryCheck != 0)
	{
		settingsModifyEntry(entryCheck, Data);
		return;
	}

	//Allocate the settings entry
	settingsEntry* newEntry = malloc(sizeof(settingsEntry));
	memset(newEntry, 0, sizeof(settingsEntry));

	//Allocate memory for the settings entry name and data
	newEntry->Name = malloc(strlen(Name) + 1);
	newEntry->Data = malloc(strlen(Data) + 1);

	//Copy the name and data
	strcpy(newEntry->Name, Name);
	strcpy(newEntry->Data, Data);

	//Double check the next entry is pointed to null
	newEntry->next = 0;

	//Find the last entry
	settingsEntry* last = settingsGetLastEntry();

	if (last != 0)
	{
		//Tack this entry on to the end
		last->next = newEntry;
	}
	else
	{
		//Set settingsListStart to this new entry
		settingsListStart = newEntry;
	}

	return;
}
