<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Dawn OS: </title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.1 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="ReleaseOne"></a>
Release 1 codename “Boot”</h2>
<p>The plans for the first iteration of Dawn are simply to have a executable, created by whatever means, that can be loaded by a bootloader and print a basic “hello world” message onto the screen. To do this several aims have to be achieved:</p>
<ul>
<li>A set of tools have to be chosen which would be versatile enough to allow me to achieve all my aims.</li>
<li>I need to select a format, and the boot loader which I am going to use for the project (at least to begin with, the OS wants to be dynamic so it must be able to run with a variety of boot loaders).</li>
<li>I need to read the Intel manual, namely the sections referring to the initial state of a monitor and how it is mapped to the address space.</li>
<li>I need to design a “Makefile” which will allow me to easily add and remove files to be compiled from my project and link created files into a base executable.</li>
<li>I need to setup a set of scripts that can start an emulated 32-Bit environment.</li>
<li>I need to write a set of shell scripts which will allow me to quickly build and test any created executables.</li>
</ul>
<h2><a class="anchor" id="ReleaseOneSummary"></a>
Release 1 summary – February 23, 2010</h2>
<p>Release 1 Implementation notes</p>
<ul>
<li>the GNU toolset was chosen, with NASM as a assembly compiler</li>
<li>I selected the ELF file format as the base system format, and GRUB as my systems boot loader</li>
<li>I have implemented a basic text-mode screen driver in C using the assumption that the PC starts with a screen in text mode that I can access using the default mapped location of memory</li>
<li>I have designed a fairly versatile makefile which will allow me to expand and contract the project and source tree with relative ease</li>
<li>I have designed a set of shell scripts which not only setup and build the OS into a CD image, but also execute a emulator with a given set of parameters, leaving small times between a build and testing.</li>
</ul>
<h2><a class="anchor" id="Release2"></a>
Release 2 “Memory”</h2>
<p>This release is primarily focused on the management of RAM and manipulation of memory maps. It has two major aims</p>
<ul>
<li>A physical memory manager which could have a list of all the free RAM chunks in memory and allocate them easily</li>
<li>A virtual memory manager that could handle the mappings between physical chunks and areas of memory</li>
</ul>
<h2><a class="anchor" id="Release2Summary"></a>
Release 2 summary – February 24, 2010</h2>
<ul>
<li>A physical memory manager which manages a stack of free areas of RAM has been added to the kernel.</li>
<li>A abstracted virtual memory manager was created to manage the mappings between physical and virtual memory</li>
<li>A paged memory model in which fixed size blocks of physical memory can be mapped to address space has been added</li>
<li>A simple segmented memory model was setup (GDT) this was more a necessity as some functions of the IA32 architecture are not available without one#</li>
</ul>
<h2><a class="anchor" id="Release3"></a>
Release 3 “Interrupts”</h2>
<p>The aim of this release is to have a abstracted interrupt mechanism within the kernel, to which callbacks could bind. It has several aims</p>
<ul>
<li>Design a abstracted set of methods which could be used to provide a versatile method of handling interrupts</li>
<li>Implement the low-level hardware code that allowed the processor to correctly handle any interrupts and pass them through the abstraction layer</li>
</ul>
<h2><a class="anchor" id="Release3Summary"></a>
Release 3 summary – March 09, 2010</h2>
<ul>
<li>A heap subsystem was required to make certain parts of the planned release work properly, and so has been added to this release as a feature</li>
<li>A set of functions which allow the registering of certain interrupt numbers with callbacks. Nice simple abstraction</li>
<li>A low level interrupt handler is implemented which stores the current state of the processor and then executes the interrupt by calling the execute method in the abstraction layer</li>
<li>The virtual memory and physical memory managers where modified and corrected to suit them more to their purposes</li>
</ul>
<h2><a class="anchor" id="Release4"></a>
Release 4 “Files”</h2>
<p>The aim of this release is to have a virtual file system setup within the kernel and a initial ram disk with which to utilize this new functionality</p>
<ul>
<li>The virtual file system, a set of structures and methods within the kernel that allow for the concept of files and directories to be used.</li>
<li>The ram disk, a initial ram disk that gets loaded by the boot loader and passed to the kernel, this will act as a base file system within which all core executables and files can be stored where they will be accessible on boot</li>
</ul>
<h2><a class="anchor" id="Release4Summary"></a>
Release 4 summary – March 20, 2010</h2>
<p>This release required lots of changes to the existing setup, and several new features where introduced which where not listed in the road map for release 4.</p>
<ul>
<li>The kernel now has a ram disk which is loaded into memory on startup, it as of yet, provides no real use to the kernel however it is fully functional as a source of read-only files on boot.</li>
<li>The kernel now has a abstracted input layer, and a keyboard driver. These features where necessary to improve my ability to test the functionality of the kernel</li>
<li>The kernel now has a virtual file system to which other file systems can be bound, such as the initial ram disk</li>
<li>Changes where made to the virtual and physical memory managers and the heap to facilitate this new functionality. Also there where bug fixs to make it work on real hardware</li>
</ul>
<h2><a class="anchor" id="Release5"></a>
Release 5 “Multitasking”</h2>
<p>This release is going to be the final step before the project actually starts to look like a operating system. The aim is to implement a set of structures and a scheduler into the kernel which will allow fake multitasking to take place (By giving each process a certain amount of time to process before the next process the illusion of true multi tasking can be achieved) The key things needed for this release are</p>
<ul>
<li>Structures and functions to create and manage and switch between tasks within the operating system. These tasks are known as processes</li>
<li>A scheduler which can keep a list of tasks and manage which process should be active.</li>
</ul>
<h2><a class="anchor" id="Release5Summary"></a>
Release 5 summary – June 13, 2010</h2>
<p>In my implementation of multi-tasking I utilized the interrupt structure I designed for release 3 to set up a interrupt that gets called repeatedly by a hardware timer (Initially I am using the programmable interrupt timer). The interrupt code will automatically store the state of the processor when it is called, so all the scheduler has to do is check if the current process has had its fill of CPU attention and if it has then switch to the next by calling a switch process function and passing the current and next process as arguments.</p>
<p>Key points:</p>
<ul>
<li>A scheduler was designed which allowed for simple round robin scheduling</li>
<li>The virtual memory managed was modified to allow for multiple address spaces for different processes but with identical kernel spaces</li>
<li>A low level process manager was designed which contains structures to store all necessary data about a process and methods to initialize, manipulate and swap between processes</li>
</ul>
<h2><a class="anchor" id="Release6"></a>
Release 6 “Applications”</h2>
<p>This release is going to focus on getting a executable loaded into physical and virtual memory from the virtual file system setup in release 4 and executing it. The key aims being:</p>
<ul>
<li>Selecting a executable format which the kernel should initially be able to parse, load and execute</li>
<li>Writing a abstracted loader for that format</li>
<li>Writing a set of high level functions which will call the loader for the format given a set of parameters (Something like loadAndExecute(fs_node_t* node))</li>
<li>Designing a API that allow the kernel and application to talk to each other and pass data.</li>
</ul>
<h2><a class="anchor" id="Release6Summary"></a>
Release 6 summary – June 30, 2010</h2>
<p>In this release I designed a set of functions that could load a simplistic executable from a popular executable file format and execute them in a new process. The key notes are that</p>
<ul>
<li>I selected the ELF binary executable format for my applications, as it is a very versatile format which is well documented and supported by most major compilers, including GCC.</li>
<li>I wrote a set of functions that allow for abstracted loading of executables</li>
<li>I wrote a loader specific to the ELF Executable though it needs improvement (To handle other archs gracefully, to handle DLL’s and relocatable code as well)</li>
<li>I wrote a API which the loaded executable can use to handle both input and output</li>
</ul>
<h2><a class="anchor" id="Release7"></a>
Release 7 “Cleanup”</h2>
<p>At this stage in the project most of the core OS functions have been added, however they are not all polished, and they do not all work nicely together. With the addition of programmable applications this starts to become a real issue as applications will being to use multiple features of the OS concurrently. To avoid these issues the seventh release will be focused not on adding any truly new features, but adding layers of abstraction and fixing up segments of code which will allow for different areas of the kernel to interact properly with each other. This is also the release in which all the features will be rigorously tested working together, instead of the previous setup in which they where tested individually</p>
<h2><a class="anchor" id="Release7Summary"></a>
Release 7 Summary – August 25, 2010</h2>
<p>The kernel was swapped to a new function naming system designed to make code easier to understand and bugs easier to find. A number of bugs where fixed, which would have had a great affect kernels stability greatly such as a bug leading to double freeing of some pages (Which would have lead to bad memory corruptions later on)</p>
<h2><a class="anchor" id="Release8"></a>
Release 8 “Applications land”</h2>
<p>This release aims to execute functions in ring-3 or userspace, a reduced execution environment in which certain areas of memory are restricted, thus preventing the kernel and hardware from being attacked by malicious code and bugs.</p>
<h2><a class="anchor" id="Release8Summary"></a>
Release 8 Summary – September 26, 2010</h2>
<p>The kernel memory manager was reprogrammed to allow user-mode programs access to read and write to the correct areas of memory, so they couldn’t damage the kernel. Getting to user-mode was fairly easy using the Intel documentation in the manual, however getting things like interrupts working properly after jumping to user mode was more of a challenge, require workarounds in the jump code to enable them without putting the kernel at risk of facing a interrupt while executing a critical piece of code. Other minor bugs such as problems with the user-mode flags within the IDT took a long time to find and fix.</p>
<h2><a class="anchor" id="Release9"></a>
Release 9 "Name change and documentation"</h2>
<p>For this release I have decided to rebrand SimpleOS with the title of Dawn. The indavidual sections will still have there specific codenames (Kernel codename and OS version codenames) but the OS as a collective will be known from this point forward as Dawn. this will require some significant changes to the files within the OS, as I have to modify or remove any reference to "SimpleOS"</p>
<h2><a class="anchor" id="Release9Summary"></a>
Release 9 Summary - 08 October 2010</h2>
<p>I renamed the repository and removed any references to SimpleOS, replacing them with Dawn. I started using Doxygen to generate documentation which could integrate documentation of the source code with my operating system theory and Dawn implementation specs.</p>
<h2><a class="anchor" id="Release10"></a>
Release 10 "Drivers"</h2>
<p>This release aims to have a simple driver interface which allows the operating system to load and execute highly privileged pieces of code which can be used to provide support for functionality and hardware that the initial release did not contain. </p>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Sat Dec 25 2010 23:02:19 for Dawn OS by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
