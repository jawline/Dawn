#include "kernel_init.h"
#include "drivers/screen.h"
#include "multiboot.h"
#include <stdio.h>
#include "gdt.h"
#include "cmos_time.h"
#include "panic.h"
#include "cmos.h"
#include <printf.h>
#include <mm/phys_mm.h>
#include <mm/virt_mm.h>
#include <heap/heap.h>
#include <threads/threads.h>
#include "kstack.h"
#include "fs/initrd.h"
#include "reboot.h"
#include <process/process.h>
#include <types/size_t.h>
#include <debug/debug.h>

#include <fs/vfs.h>
#include <fs/dir.h>

#include <stdlib.h>

#define iprintf(x) if (visual_output) { printf(x); }

void init_screen() //All we really need to do here is clear the screen
{
	text_mode_clearscreen();
}

void init_GDT(int visual_output) 
{
   initialize_gdt();
   iprintf("GDT [OK]\n");
}

void init_IDT(int visual_output) 
{
   Initialize_IDT();
   iprintf("IDT [OK]\n");
}

//Initialize the physical and virtual memory managers
//Use the last loaded module (The one after the RAM disk)
void init_MemoryManagers(struct multiboot * mboot_ptr, int visual_output)
{
    uint32 * mods_addr = (uint32 *)mboot_ptr->mods_addr;    
    mods_addr++;

    init_phys_mm(mods_addr);
    init_virt_mm(mods_addr);
    map_free_pages(mboot_ptr);
    iprintf("Memory Managers (PMM, VMM) [OK]\n");
}

//Init the system clock
void init_Timer(int visual_output) 
{
   init_timer(100);
   iprintf("System Timer [OK]\n");
}

void init_ramdisk(struct multiboot * mboot_ptr, fs_node_t * root) 
{

	if (mboot_ptr->mods_count != 1) {
		printf("Error, Initial RAM disk not loaded\n");
		PANIC("No RAM disk");
		return;	
	}

	fs_node_t * initrd = initialize_initrd(*((uint32*)mboot_ptr->mods_addr), "system", init_vfs() /* Returns root */);
	bindnode_fs(init_vfs() /* returns root */ , initrd);
}

//Run all the initial -one time- kernel initialization routines - once this is called the Kernel assumes a valid Heap, Page directory, Physical and virtual memory manager, etc
void init_kernel(struct multiboot * mboot_ptr, int visual_output, size_t initial_esp) //visual_output signals whether or not to call printf
{
	init_screen();
	iprintf("Initialization Started\n");
	init_GDT(visual_output);
	init_IDT(visual_output);

	init_MemoryManagers(mboot_ptr, visual_output);

	init_Timer(visual_output);

	//Initialize the kernel heap
        init_kheap();
   
	//Initialize the main thread (Or, in other words, setup the kernel as a single thread) and initialize the thread scheduler
	thread_t * maint = initialize_threading();
	initialize_thread_scheduler(maint);

	//Initialize the process scheduler & create the kernel process
	process_t * kproc = initialize_kernel_process();
	initialize_process_scheduler(kproc);

	fs_node_t * rootfs = init_vfs();
	init_ramdisk(mboot_ptr, rootfs);

	//Reason for moving the stack. fork() needs to copy a stack, however when its < the kernels end (As grub sets it up) it will be identity mapped, not copied
	//If its moved into higher memory, it gets copied, so fork() causes two processes with indavidual stacks to be created.
	move_stack(KERNEL_STACK_START, KERNEL_STACK_SIZE, initial_esp);
	
	extern page_directory_t* kernel_pagedir;

	page_directory_t* page_directory = kernel_pagedir;
	page_directory_t* new_page_directory = copy_page_dir(page_directory);

	DEBUG_PRINT("Switching page dir\n");

	PANIC("FAIL\n");
	
	iprintf("End of initialization\n");
}
