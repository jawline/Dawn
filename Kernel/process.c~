#include <process/process.h>
#include <stdlib.h>
#include <stdio.h>
#include <common.h>
#include <mm/virt_mm.h>

uint32 c_pid = 0;

//Returns whether the process is killable or not. (1 = true, 0 = false)
uint8 p_killable(process_t* proc) 
{
	if ((proc->pflags & PROC_FLAG_KILLABLE) == PROC_FLAG_KILLABLE) {
		return 1;	
	}

return 0;
}

process_t* initialize_kernel_process()
{
	extern page_directory_t* kernel_pagedir;

	process_t * ret = malloc(sizeof(process_t));
	memset(ret, 0, sizeof(process_t)); //Inialize it to 0
	ret->pid = c_pid++;
	ret->page_dir = kernel_pagedir;
	strcpy(ret->name, "kernel");

	return ret;
}

process_t* fork(const char * Name)
{
	disable_interrupts();
	uint32 parent_pid = current_pid();

	extern page_directory_t* kernel_pagedir;
	page_directory_t* pagedir = copy_page_dir(kernel_pagedir);

	process_t* ret = malloc(sizeof(process_t));
	memset(ret, 0, sizeof(process_t));
	ret->pid = c_pid++;
	strcpy(ret->name, Name);
	ret->page_dir = pagedir;
	ret->esp = ret->ebp = 0;

	extern uint32 read_eip();
	uint32 eip = read_eip();

	if (current_pid() == parent_pid)
	{
	       //Setup the stack etc for the child
	       uint32 esp; asm volatile("mov %%esp, %0" : "=r"(esp));
	       uint32 ebp; asm volatile("mov %%ebp, %0" : "=r"(ebp));
	       ret->esp = esp;
	       ret->ebp = ebp;
	       ret->eip = eip;
	       return ret;
	}
	else
	{
		return 0;
	}
}
